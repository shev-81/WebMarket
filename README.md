<h1 align="center">Интернет магазин. 
<h3 align="center"> на микросервисной архитектуре - Spring Boot, REST, Docker, Kafka</h3>

<a href="https://shev-81.github.io/WebMarket/"><img src="https://img.shields.io/badge/WebMarket-JavaDoc-green"/>  </a>

## 0. `Предисловие`
Проект написан, в рамках изучения мной `REST` архитектуры взаимодействия между микросервисами, и я решил создать собственный интернет магазин продуктов (в качестве продуктов можно рассматривать все что угодно, это всего лиш вопрос расширения функционала). Мной рассматривалось два варианта реализации архитектуры. 
 
 - Первый вариант, это использование `Eureca от Netflix` в качестве `Discovery service` и `Rabbit MQ` в качестве брокера сообщений между сервисами.
 
 - Второй вариант, это работать с настроенным вручную `GateWay`, где определить маршрутизацию для каждого микросервиса за ним и использовать Kafka как брокер сообщения между сервисами. Я выбрал - работать с `GateWay` и `Kafka`, пример горизонтально маштабируемой структыры проекта с `Eureca Netflix` и `Rabbit MQ` можно увидеть в другом моем репозитарии.
 
> <b>Техническая часть</b>
 - `IDE: IntelliJ IDEA 2021.3.3`
 - `Версия JDK: 17.0.1 .`
 - `Apache Kafka`
 - `Postgresql`, `MySql`, `Redis`
 - `Docker`, `FlyWay`
 - `Spring framework`
> <b>Используемые технологии:</b>
 - `Java`
 - `Spring Boot`, `Hibernate`, `Data Jpa`, `Paypal sdk` 
 - `Angular JS`, `HTML`, `Bootstrap`, `CSS`
 - `Spring Cloud`, `Feign client`, `Web client`, `Discovery service - GateWay`
 - `Java Doc`, `Swager`
 - `Lombok`
 - `SOAP` 
 - `Stream API`
 - `Мавен 3.5`

В проекте использованы несколько баз данных `MySQL`, `Postgres`, `Redis`. Имеет единую точку входа через GateWay с настроеной маршрутизацией, а фронте настроена маршрутизация для перемещения пользователей на JS. Общая архитектура проекта представлена ниже на схеме.

![schema_project](https://user-images.githubusercontent.com/89448563/192151653-d168536e-62fc-4223-9bd5-e1b7ac2d3d77.png)

> В проекте магазина реализован основной функционал для покупки товаров: 
Добавить товар в корзину -> Cформировать заказ -> Оплатить заказ через PayPal.


## 1. `Front Service (Фронт магазина)`
Работает с фронтом всех разделов магазина, маршрутизирует перемещение пользователя. Этот сервис включает в себя все страницы html
по всем разделам магазина, а так же файлы скриптов на `Angular JS` для этих страниц. 

> Вид каталога товаров на фронте.

![prodaction](https://user-images.githubusercontent.com/89448563/192355576-12da5359-538a-4825-a812-ca198f8080d3.png)

> Для ускорения разработки были использованы стили `CSS Bootstrap`, которые позволили не отрисовывать графические элементы дизайна, а взять и использовать готовые.

В каталоге товаров на фронте реализована пагинация и фильтр по категориям товаров. Товар из каталога можно добавить в корзину. Корзина для каждого пользователя своя,
что не исключает ее использование не авторизованным пользователем, для этого ему будет создана временная корзина. Положив товары в корзину из каталога тоаваров, в разделе `Корзина` будут показаны все выбранные товары и перерасчитаны в соотвветствии со стоимостью и количеством. Корзина позволяет продолжить процесс оформления выбранных товаров и создать `Заказ`. Создав заказ и введя детальные данные о доставке, можно сразу же его оплатить он-лайн при помощи платежной системы `PayPal`. 

> Платежная система `PayPal`, подключена в режиме песочницы, но от реално проводимых платежей отделяет всего лишь настроенный профиль в личном кабинеет  платежной системы и включение опции проводить реальные платежи.  

И наконец проведя оплату статус заказа поменятся на - ОПЛАЧЕН. 

![orders](https://user-images.githubusercontent.com/89448563/193060389-8c24445f-1d5c-4b9a-81db-15c706f899ca.png)

## 2. `Auth Service (Сервис Авторизации)`

Работа микросервиса строится на тесном взаимодействии со Spring Security. В базе данных пользователей хранятся не только данные необходимые для работы Security, но и  дополнительные для работы магазина. Как частный случай это детальная информация пользователя - телефон адрес и т.п.

 
 > Сервис решает следующие задачи:
 
 - Проведение авторизации пользователей и при успешном результате, выдача токена доступа для прохождения GateWay.
 - Регистрация новых пользователей.
 - Выполнение CRUD операций с записями пользователей через раздел администратора.
 

![AuthService](https://user-images.githubusercontent.com/89448563/195896840-397161c7-eba7-4e74-9c6f-c3cfafb62f1e.png)
 

Сервис содержит в себе Модуль безопасности выдающий токены использующий в своей работе Базу данных `Postgres`, для хранения информации о пользователях магазина. При успешном прохождении процесса авторизации пользователь получает `JWT` - `Java Web Token` и сохраняет его в хранилище браузера на фронте. В последствии использует `JWT`  при прохождении запросов через `GateWay`. Токен имеет срок годности и если он истек, то потребуется по новой пройти процедуру его получения. 

Необходимо отметить, что все запросы проходят через GateWay! Для сторонних запросов потребуется `JWT`, а микро сервисы прописанны в конфигурации GateWay.

## 3. `Cart Service (Сервис корзины)`
МС корзины пользователей - как упоминалось выше, корзина создается для каждого пользователя при добавлении товаров. Если пользователь не авторизован на момент добавления товара, то создается временная корзина, но при дальнейшем оформлении заказа потребуется пройти процесс авторизации и после него корзина сохранится в `DB Redis` с уникальным префиксом пользователя и будет за ним закреплена. 

> В работе корзины есть нюанс, когда пользователь не авторизован и добавляет в нее товары (в этот моент он использует временную корзину). Но что будет если он со списком товаров в корзине и в статусе не зарегистрированного авторизуется? Он получит свою корзину, которую создавал под своей учетной записью ранее? Или к примеру если корзина, заполняемая ранее уже имеет в себе список товаров? Для этого придется объеденить 2 корзины в 1, переложив в корзину зарегистрированного пользователя все товары и прерасчитать их стоимость.

 - Метод объединения merge() объединяет корзины в одну. 
 

          public void merge(Cart another) {
                  for (CartItem anotherItem : another.items) {
                      boolean merged = false;
                      for (CartItem myItem : items) {
                          if (myItem.getProductId().equals(anotherItem.getProductId())) {
                              myItem.changeQuantity(anotherItem.getQuantity());
                              merged = true;
                              break;
                          }
                      }
                      if (!merged) {
                          items.add(anotherItem);
                      }
                  }
                  recalculate();
                  another.clear();
           }

После такого объединения, временная корзина останется в `Redis` но не будет содержать данные и в последствии заданного времени запись будет подчищена самой БД.(Тут нужно упомянуть, что нет смысла держать временные данные долго и БД будет их вычищать после определенного периода хранения). 
Дальнейший шаг это оформление заказа. И после его создания данные из корзины будут перенесены в созданный заказ (`MS CartService` -> передаст данные в `MS CoreService`).

## 4. `Core Service (Сервис Ядро магазина)`

Это основной программный модуль магазина - содержит логику работы с товарами, категориями, заказами пользователей и взаимодействием с платежной системой `PayPal`. 

Сервис интегрирован с корзиной пользователя `Cart Service`, `Auth Service`, а так же с платежной системой `PayPal`. Основная задача данного сервиса - по запросам с фронта предоставить информацию из БД о продуктах, категориях продуктов и заказах пользователя.

- Работа с БД `PostgreSQL` реализованна через `Hibernate ORM`, с использованием `Data JPA`. 
- Сервис содержит весь набор контроллеров для взаимодействия с каталогом продуктов и заказами пользователя.
- Интегрирован с Analit Service через `Apache Kafka`. 

Визуально процесс помещения товара пользователем в корзину выглядит так.

![Core_service](https://user-images.githubusercontent.com/89448563/196040946-9e4eba9d-40b5-44dc-935a-c477439de809.png)

В сервисе реализованн `SOAP API` для получения списка товаров и списка категорий товаров. Взаимодействие с `Cart Service` налаженно через через `Web Client`. Данные о товарах и заказах хранятся в БД `Postgres`.

Хотелось бы так же упоминуть об обработке ошибок возникаемых при работе сервиса. Так как сервис по сути является центральным хабом получения информации для фронта и может взаимодействовать с другими микросервисами системы то при получении ошибки из другого микросервиса он пробрасывает ощибки по цепочке далее. Вариант настроенного `WebClient` на соединение с `CartService` приведен ниже.

        public CartDto getUserCart(String username) {
            CartDto cart = cartServiceWebClient.get()
                    .uri("/api/v1/cart/0")
                    .header("username", username)
                    .retrieve()
                    .onStatus(HttpStatus::is4xxClientError, clientResponse -> Mono.error(new CartServiceIntegrationException("An incorrect request to the shopping cart service was made")))
                    .onStatus(HttpStatus::is5xxServerError, clientResponse -> Mono.error(new CartServiceIntegrationException("The shopping cart service is broken")))
                    .bodyToMono(CartDto.class)
                    .block();
            return cart;
        }

Тут в зависимости от кода вернувшейся ошибки из `CartService` (в данном случае ловятся все `4хх` и `5хх` ошибки), будет создан ответ для фронта и фронт поймав его покажет ошибку пользователю. Пример ниже.

        $scope.checkOut = function () {
             $http({
                 url: 'http://localhost:5555/core/api/v1/orders',
                 method: 'POST',
                 data: $scope.orderDetails
             }).then(function successCallback(response) {
                 $scope.loadCart();
                 $scope.orderDetails = null
             }, function errorCallback(response) {
                 console.log("Сервис лежит");
                 let exceptionObj = response.data.message;
                 alert("Ошибка " + exceptionObj);
             });
         };

И конечно же в проекте используется глобальный перехватчик исключений `GlobalExceptionHandler`, который перехватывает необработанные исключения и обрабатывает их в соответствии с логикой или пробрасывает на фронт используя ResponseEntity класс. Пример перхватчика ниже.

         @ExceptionHandler
         public ResponseEntity<AppError> catchResourceNotFoundException(ResourceNotFoundException e) {
             log.error(e.getMessage(), e);
             return new ResponseEntity<>(new AppError(HttpStatus.NOT_FOUND.value(), e.getMessage()), HttpStatus.NOT_FOUND);
         }

## 5. `Analityc Service (Сервис Аналитики)`
Получает из брокера сообщений `Kafka` объекты от `Core Service` и сохраняет их в `БД MySQL`. Здесь нужно сказать, что это объекты содержащие данные о добавляемом товаре в корзину покупателя содержат в себе названия продуктов. При загрузке стартовой страницы магазина,  данные показываются в виде списка востребованных товаров, подгруженного из БД сервиса аналитики.

## 6. `GateWay Service (BackEnd маршрутизация между сервисами магазина)`
Настроена маршрутизация по MS магазина с проверкой валидности доступа.

## 7. `Docker` 
Для разворачивания окружжения через докер необходимо запустить файл: /flayway/start-migration.bat 
Он развернет несколько образов в Docker необходимых для работы (MySQL, Postgress, Redis), а так же запустит скрипты для миграции.
